<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emotional Stroop Task - Two Colors</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.min.js"></script>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #d8f3dc 0%, #2575fc 100%);
      margin: 0; padding: 20px;
      display: flex; justify-content: center; align-items: center; min-height: 100vh;
      color: #333;
    }
    #container {
      background-color: white;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      padding: 30px;
      width: 90%;
      max-width: 800px;
      text-align: center;
      position: relative;
    }
    .language-switcher {
      position: absolute;
      top: 20px;
      right: 20px;
    }
    .language-btn {
      background: #3498db;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 14px;
      cursor: pointer;
      margin-left: 5px;
      transition: all 0.3s;
    }
    .language-btn:hover {
      background: #2980b9;
    }
    .language-btn.active {
      background: #2c3e50;
    }
    h1 { color: #2c3e50; margin-bottom: 20px; }
    h2 { color: #3498db; margin-top: 25px; }
    p { line-height: 1.6; margin-bottom: 15px; }
    .instructions {
      background-color: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      text-align: left;
    }
    .key-instruction {
      display: inline-block;
      background: #e0e0e0;
      padding: 5px 15px;
      border-radius: 5px;
      margin: 5px;
      font-weight: bold;
    }
    .blue-key { color: #2980b9; }
    .red-key { color: #e74c3c; }
    .yellow-key { color: #f1c40f; }
    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 50px;
      font-size: 18px;
      cursor: pointer;
      margin: 20px 0;
      transition: all 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    button:hover {
      background: #2980b9;
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
    }
    #canvas-container {
      margin: 20px auto;
      width: 100%;
      text-align: center;
    }
    .feedback {
      font-size: 24px;
      font-weight: bold;
      margin: 15px 0;
    }
    .progress-bar {
      height: 10px;
      background: #ecf0f1;
      border-radius: 5px;
      margin: 20px 0;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #3498db;
      width: 0%;
      transition: width 0.3s;
    }
    .results {
      text-align: left;
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
    }
    .error {
      color: #e74c3c;
    }
    #email-section {
      margin-bottom: 30px;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    .results-table th, .results-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    .results-table th {
      background-color: #f2f2f2;
    }
    .word-type-emotional {
      background-color: #ffe6e6;
    }
    .word-type-neutral {
      background-color: #e6f2ff;
    }
    .summary-box {
      background-color: #f8f9fa;
      border-left: 4px solid #3498db;
      padding: 15px;
      margin: 15px 0;
      border-radius: 4px;
    }
    .block-info {
      background-color: #e8f4fc;
      padding: 10px;
      border-radius: 8px;
      margin: 10px 0;
      font-weight: bold;
    }
    .timer {
      font-size: 36px;
      font-weight: bold;
      color: #e74c3c;
      margin: 20px 0;
    }
    .timer-container {
      background-color: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
 <div id="container">
    <!-- Language Switcher -->
    <div class="language-switcher">
      <button id="lang-en" class="language-btn active">EN</button>
      <button id="lang-sv" class="language-btn">SV</button>
    </div>

    <h1 id="main-title">Emotional Stroop Task</h1>

    <!-- Email Entry Section -->
    <div id="email-section">
      <p id="email-instruction">
        Hi, welcome back for the second part of the experiment.<br>
        In this section, you will be required to perform a Stroop Task.<br>
        Please enter the email address you used in the Multilingualism and Emotional Questionnaire (MEQ):
      </p>
      <input type="email" id="email-input" placeholder="your.email@example.com"
             style="padding: 10px; width: 80%; max-width: 400px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px;" />
      <div id="email-error" style="color: #e74c3c; margin-top: 10px; display: none;">Please enter a valid email address.</div>
      <button id="email-submit-btn">Continue</button>
    </div>

    <!-- Intro -->
    <div id="intro" style="display: none;">
      <div class="instructions">
        <p id="intro-description">This study involves categorizing the ink color of words as quickly and accurately as possible.</p>
        <p><strong id="procedure-title">Procedure:</strong> <span id="procedure-text">You will see words in different colors. Your task is to indicate the color of the <strong>ink</strong>, not the word itself.</span></p>
        <p id="key-instructions">
          Press <span class="key-instruction red-key">Z</span> for <span style="color: #e74c3c;">RED</span>,
          <span class="key-instruction yellow-key">V</span> for <span style="color: #f1c40f;">YELLOW</span>, and
          <span class="key-instruction blue-key">M</span> for <span style="color: #2980b9;">BLUE</span>.
        </p>
        <p><em id="practice-note">First, you'll complete 4 short practice blocks.</em></p>
      </div>
      
      <!-- Timer for initial instructions -->
      <div id="initial-timer-container" class="timer-container">
        <p id="timer-instruction">Please take a moment to review the instructions and remember the keys.</p>
        <div id="initial-timer" class="timer">02:00</div>
        <p id="timer-note">The experiment will start automatically when the timer reaches zero.</p>
        <button id="skip-initial-timer">Start Now</button>
      </div>
    </div>

    <!-- Message screen -->
    <div id="message-screen" style="display:none;"></div>

    <!-- Experiment -->
    <div id="experiment" style="display: none;">
      <div id="block-info" class="block-info"></div>
      <div class="progress-bar"><div class="progress" id="progress"></div></div>
      <div id="canvas-container"></div>
      <div id="feedback" class="feedback"></div>
      <div id="results" class="results" style="display: none;">
        <h2 id="complete-title">Experiment Complete!</h2>
        <p id="thank-you-text">Thank you for your participation.</p>
        <h3 id="summary-title">Summary Results</h3>
        <div id="results-content"></div>
        <button id="download-csv" style="margin-top: 15px;">Download CSV</button>
      </div>
    </div>
  </div>

  <script>
    // Language texts
    const translations = {
      en: {
        mainTitle: "Emotional Stroop Task",
        emailInstruction: "Hi, welcome back for the second part of the experiment.<br>In this section, you will be required to perform a Stroop Task.<br>Please enter the email address you used in the Multilingualism and Emotional Questionnaire (MEQ):",
        emailPlaceholder: "your.email@example.com",
        emailError: "Please enter a valid email address.",
        continueBtn: "Continue",
        introDescription: "This study involves categorizing the ink color of words as quickly and accurately as possible.",
        procedureTitle: "Procedure:",
        procedureText: "You will see words in different colors. Your task is to indicate the color of the <strong>ink</strong>, not the word itself.",
        keyInstructions: "Press <span class='key-instruction red-key'>Z</span> for <span style='color: #e74c3c;'>RED</span>, <span class='key-instruction yellow-key'>V</span> for <span style='color: #f1c40f;'>YELLOW</span>, and <span class='key-instruction blue-key'>M</span> for <span style='color: #2980b9;'>BLUE</span>.",
        practiceNote: "First, you'll complete 4 short practice blocks.",
        timerInstruction: "Please take a moment to review the instructions and remember the keys.",
        timerNote: "The experiment will start automatically when the timer reaches zero.",
        startNowBtn: "Start Now",
        trialComplete: "Trial Block complete.",
        nextBlockStarts: "Next block will start in:",
        breakReminder: "Reminder:",
        nextTrialBtn: "Start Next Trial Block Now",
        initialTrialsDone: "The initial trial blocks are done.",
        realExperimentStarts: "The real experiment will start now.",
        startRealBtn: "Start Real Experiment",
        blockComplete: "Block complete.",
        startNextBlock: "Start Next Block Now",
        completeTitle: "Experiment Complete!",
        thankYouText: "Thank you for your participation.",
        summaryTitle: "Summary Results",
        downloadCSV: "Download CSV",
        overallPerformance: "Overall Performance:",
        totalTrials: "Total trials:",
        responded: "Responded:",
        accuracy: "Accuracy:",
        averageRT: "Average RT (correct):",
        performanceByType: "Performance by Word Type:",
        emotionalWords: "Emotional Words:",
        neutralWords: "Neutral Words:",
        trialDetails: "Trial Details:",
        trialNumber: "#",
        word: "Word",
        type: "Type",
        language: "Language",
        color: "Color",
        response: "Response",
        rt: "RT",
        correct: "Correct",
        block: "Block",
        yes: "Yes",
        no: "No",
        practice: "practice",
        emotional: "emotional",
        neutral: "neutral",
        red: "RED",
        yellow: "YELLOW",
        blue: "BLUE"
      },
      sv: {
        mainTitle: "Emotionell Stroop Uppgift",
        emailInstruction: "Hej, välkommen tillbaka för den andra delen av experimentet.<br>I denna del kommer du att utföra en Stroop-uppgift.<br>Ange e-postadressen du använde i flerspråkighets- och känslofrågeformuläret (MEQ):",
        emailPlaceholder: "din.epost@exempel.com",
        emailError: "Vänligen ange en giltig e-postadress.",
        continueBtn: "Fortsätt",
        introDescription: "Denna studie innebär att kategorisera bläckfärgen på ord så snabbt och korrekt som möjligt.",
        procedureTitle: "Procedur:",
        procedureText: "Du kommer att se ord i olika färger. Din uppgift är att ange <strong>bläckfärgens</strong> färg, inte själva ordet.",
        keyInstructions: "Tryck <span class='key-instruction red-key'>Z</span> för <span style='color: #e74c3c;'>RÖD</span>, <span class='key-instruction yellow-key'>V</span> för <span style='color: #f1c40f;'>GUL</span>, och <span class='key-instruction blue-key'>M</span> för <span style='color: #2980b9;'>BLÅ</span>.",
        practiceNote: "Först kommer du att genomföra 4 korta övningsblock.",
        timerInstruction: "Ta en stund att gå igenom instruktionerna och kom ihåg tangenterna.",
        timerNote: "Experimentet startar automatiskt när timern når noll.",
        startNowBtn: "Starta Nu",
        trialComplete: "Övningsblock klar.",
        nextBlockStarts: "Nästa block startar om:",
        breakReminder: "Påminnelse:",
        nextTrialBtn: "Starta Nästa Övningsblock Nu",
        initialTrialsDone: "De inledande övningsblocket är klara.",
        realExperimentStarts: "Det riktiga experimentet börjar nu.",
        startRealBtn: "Starta Riktigt Experiment",
        blockComplete: "Block klar.",
        startNextBlock: "Starta Nästa Block Nu",
        completeTitle: "Experimentet Avslutat!",
        thankYouText: "Tack för din medverkan.",
        summaryTitle: "Sammanfattande Resultat",
        downloadCSV: "Ladda ner CSV",
        overallPerformance: "Övergripande Prestanda:",
        totalTrials: "Totalt antal försök:",
        responded: "Svarade:",
        accuracy: "Noggrannhet:",
        averageRT: "Genomsnittlig RT (korrekt):",
        performanceByType: "Prestanda efter Ordtyp:",
        emotionalWords: "Känslomässiga Ord:",
        neutralWords: "Neutrala Ord:",
        trialDetails: "Försöksdetaljer:",
        trialNumber: "#",
        word: "Ord",
        type: "Typ",
        language: "Språk",
        color: "Färg",
        response: "Svar",
        rt: "RT",
        correct: "Korrekt",
        block: "Block",
        yes: "Ja",
        no: "Nej",
        practice: "övning",
        emotional: "känslomässig",
        neutral: "neutral",
        red: "RÖD",
        yellow: "GUL",
        blue: "BLÅ"
      }
    };

    const emotionWords = {
      sv: ["nervös", "sorg", "upprörd", "girighet", "ångest", "avundsjuka", "ensam", "rädd", "rädsla", "panik", "arg", "äcklad", "deprimerad", "galen", "oroad"],
      en: ["nervous", "grief", "upset", "greed", "anxiety", "jealousy", "lonely", "scared", "afraid", "panic", "angry", "disgusted", "depressed", "mad", "troubled"],
      it: ["nervoso", "dolore", "sconvolto", "avidità", "ansia", "gelosia", "solo", "spaventato", "paura", "panico", "arrabbiato", "disgustato", "depresso", "furioso", "turbato"]
    };
    const neutralWords = {
      sv: ["motor", "bom", "akter", "hytt", "köl", "ratt", "säte", "däck", "förare", "propeller", "golv", "ankare", "paddel", "balk", "babord", "rep"],
      en: ["engine", "boom", "stern", "cabin", "keel", "steering wheel", "seat", "deck", "driver", "propeller", "floor", "anchor", "paddle", "beam", "port", "rope"],
      it: ["motore", "bravvio", "poppa", "cabina", "chiglia", "volante", "sedile", "ponte", "conducente", "elica", "pavimento", "ancora", "pagaia", "trave", "sinistro", "corda"]
    };

    const multilingualTrials = {
      animals: ["hund", "katt", "val", "tiger", "lejon", "groda", "delfin", "panda", "koala", "sengångare", "cane", "gatto", "balena", "tigre", "leone", "rana", "delfino", "panda", "koala", "bradipo", "dog", "cat", "whale", "tiger", "lion", "frog", "dolphin", "panda", "koala", "sloth"],
      plants: ["orkidé", "sekvoja", "ormbunke", "kaktus", "lavendel", "bambu", "solros", "lilja", "mossa", "maskros", "orchidea", "sequoia", "felce", "cactus", "lavanda", "bambù", "girasole", "giglio", "muschio", "dente di leone", "orchid", "sequoia", "fern", "cactus", "lavender", "bamboo", "sunflower", "lily", "moss", "dandelion"],
      food: ["spaghetti", "croissant", "guacamole", "cheesecake", "kebab", "pannkaka", "sushi", "lasagne", "tiramisu", "curry", "pancake", "lasagna"],
      transport: ["helikopter", "ubåt", "skateboard", "bil", "flygplan", "skoter", "kajak", "motorcykel", "taxi", "båt", "elicottero", "sottomarino", "skateboard", "auto", "aereo", "scooter", "kayak", "motocicletta", "taxi", "barca", "helicopter", "submarine", "skateboard", "car", "plane", "scooter", "kayak", "motorcycle", "taxi", "boat"]
    };

    const colors = { red: "#e74c3c", yellow: "#f1c40f", blue: "#2980b9" };
    const colorKeysMap = { red: 'z', yellow: 'v', blue: 'm' };
    const keyColorMap = { 'z': 'red', 'v': 'yellow', 'm': 'blue' };

    let state = 'consent', currentTrialIndex = 0, totalTrials = 0, startTime = 0, trials = [], trialTimeout = null, errorTimeout = null, fixationShown = false;
    let initialTrialBlocks = [], currentBlock = 0;
    let canvas;
    let allTrials = []; // Store all trials for final results
    let timerInterval = null; // For managing the timer intervals
    let currentLanguage = 'en'; // Default language

    // Function to update all text content based on current language
    function updateLanguage(lang) {
      currentLanguage = lang;
      const t = translations[lang];
      
      // Update all text elements
      document.getElementById('main-title').textContent = t.mainTitle;
      document.getElementById('email-instruction').innerHTML = t.emailInstruction;
      document.getElementById('email-input').placeholder = t.emailPlaceholder;
      document.getElementById('email-error').textContent = t.emailError;
      document.getElementById('email-submit-btn').textContent = t.continueBtn;
      document.getElementById('intro-description').textContent = t.introDescription;
      document.getElementById('procedure-title').textContent = t.procedureTitle;
      document.getElementById('procedure-text').innerHTML = t.procedureText;
      document.getElementById('key-instructions').innerHTML = t.keyInstructions;
      document.getElementById('practice-note').textContent = t.practiceNote;
      document.getElementById('timer-instruction').textContent = t.timerInstruction;
      document.getElementById('timer-note').textContent = t.timerNote;
      document.getElementById('skip-initial-timer').textContent = t.startNowBtn;
      document.getElementById('complete-title').textContent = t.completeTitle;
      document.getElementById('thank-you-text').textContent = t.thankYouText;
      document.getElementById('summary-title').textContent = t.summaryTitle;
      document.getElementById('download-csv').textContent = t.downloadCSV;
      
      // Update language buttons
      document.getElementById('lang-en').classList.toggle('active', lang === 'en');
      document.getElementById('lang-sv').classList.toggle('active', lang === 'sv');
    }

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function createTrials(wordArray) {
      const colorKeys = Object.keys(colors);
      return shuffleArray(wordArray.map(word => {
        const color = colorKeys[Math.floor(Math.random() * colorKeys.length)];
        return {
          word,
          color,
          stimulus: `${word} (${color})`,
          responseKey: null,
          responseTime: null,
          correct: null,
          type: 'practice' // Mark as practice trial
        };
      }));
    }
    
    function randomColor() {
      const colorKeys = Object.keys(colors);
      return colorKeys[Math.floor(Math.random() * colorKeys.length)];
    }

    function initInitialTrials() {
      const selectedWords = [];
      Object.values(multilingualTrials).forEach(category => {
        const unique = Array.from(new Set(category));
        selectedWords.push(shuffleArray(unique).slice(0, 10));
      });
      initialTrialBlocks = selectedWords.map(createTrials);
      trials = initialTrialBlocks[currentBlock];
      totalTrials = trials.length;
      currentTrialIndex = 0;
      updateProgressBar();
    }

    function initRealExperimentTrials() {
      function getRandomWords(wordObj, type) {
        const combined = [];
        const keys = Object.keys(wordObj);
        const perLangCount = Math.floor(15 / keys.length);

        keys.forEach(lang => {
          const words = shuffleArray(wordObj[lang]).slice(0, perLangCount);
          words.forEach(w => combined.push({ word: w, lang, type }));
        });

        return shuffleArray(combined);
      }

      const emotionTrials = getRandomWords(emotionWords, 'emotional').map(item => {
        const color = randomColor();
        return {
          word: item.word,
          lang: item.lang,
          color,
          stimulus: `${item.word} (${color})`,
          responseKey: null,
          responseTime: null,
          correct: null,
          type: item.type, // Mark as emotional word
          block: 'emotional' // Add block identifier
        };
      });

      const neutralTrials = getRandomWords(neutralWords, 'neutral').map(item => {
        const color = randomColor();
        return {
          word: item.word,
          lang: item.lang,
          color,
          stimulus: `${item.word} (${color})`,
          responseKey: null,
          responseTime: null,
          correct: null,
          type: item.type, // Mark as neutral word
          block: 'neutral' // Add block identifier
        };
      });

      // Create separate blocks for emotional and neutral words
      window.realExperimentBlocks = [
        {trials: emotionTrials, type: 'emotional', name: currentLanguage === 'en' ? 'Emotional Words Block' : 'Känslomässiga Ord Block'},
        {trials: neutralTrials, type: 'neutral', name: currentLanguage === 'en' ? 'Neutral Words Block' : 'Neutrala Ord Block'}
      ];
      
      window.realBlockIndex = 0;

      trials = realExperimentBlocks[realBlockIndex].trials;
      totalTrials = trials.length;
      currentTrialIndex = 0;
      updateProgressBar();
      
      // Update block info display
      document.getElementById('block-info').textContent = realExperimentBlocks[realBlockIndex].name;
    }

    function updateProgressBar() {
      document.getElementById('progress').style.width = `${(currentTrialIndex / totalTrials) * 100}%`;
    }

    function showFixation() {
      clearCanvas();
      textSize(36);
      fill(0);
      text("+ + + + +", width / 2, height / 2);
      fixationShown = false;
      setTimeout(() => {
        fixationShown = true;
        showWord();
      }, 300);
    }
    
    function showWord() {
      const trial = trials[currentTrialIndex];
      drawWord(trial.word, colors[trial.color]);
      startTime = millis();
      trialTimeout = setTimeout(() => processTrialResult(null, null), 2500);
    }

    function processTrialResult(key, rt) {
      if (trialTimeout) clearTimeout(trialTimeout);
      const trial = trials[currentTrialIndex];
      if (key !== null) {
        trial.responseKey = key;
        trial.responseTime = rt;
        trial.correct = (keyColorMap[key] === trial.color);
        if (!trial.correct) {
          document.getElementById('feedback').textContent = currentLanguage === 'en' ? 'ERROR' : 'FEL';
          document.getElementById('feedback').className = 'feedback error';
          errorTimeout = setTimeout(() => advanceToNextTrial(), 750);
          return;
        }
      } else {
        trial.correct = false;
      }
      advanceToNextTrial();
    }

    function advanceToNextTrial() {
      document.getElementById('feedback').textContent = '';
      currentTrialIndex++;
      updateProgressBar();

      if (currentTrialIndex >= totalTrials) {
        if (state === 'initial-trial') {
          currentBlock++;
          if (currentBlock < initialTrialBlocks.length) {
            document.getElementById('experiment').style.display = 'none';
            document.getElementById('message-screen').style.display = 'block';
            
            // Show timer for break between trial blocks
            let breakTime = 60; // 1 minute
            const t = translations[currentLanguage];
            document.getElementById('message-screen').innerHTML = `
              <p><strong>${t.trialComplete}</strong></p>
              <p>${t.nextBlockStarts}</p>
              <div id="break-timer" class="timer">00:${breakTime < 10 ? '0' + breakTime : breakTime}</div>
              <p>${t.breakReminder}</p>
              <p>${t.keyInstructions}</p>
              <button id="next-trial-btn">${t.nextTrialBtn}</button>
            `;
            
            // Start the break timer
            timerInterval = setInterval(() => {
              breakTime--;
              document.getElementById('break-timer').textContent = `00:${breakTime < 10 ? '0' + breakTime : breakTime}`;
              
              if (breakTime <= 0) {
                clearInterval(timerInterval);
                startNextTrialBlock();
              }
            }, 1000);
            
            // Add event listener for the skip button
            document.getElementById('next-trial-btn').addEventListener('click', () => {
              clearInterval(timerInterval);
              startNextTrialBlock();
            });
            return;
          } else {
            state = 'message';
            document.getElementById('experiment').style.display = 'none';
            document.getElementById('message-screen').style.display = 'block';
            const t = translations[currentLanguage];
            document.getElementById('message-screen').innerHTML = `
              <p><strong>${t.initialTrialsDone}</strong></p>
              <p>${t.realExperimentStarts}</p>
              <button id="start-real-btn">${t.startRealBtn}</button>
            `;
            document.getElementById('start-real-btn').addEventListener('click', startRealExperiment);
            return;
          }
        } else if (state === 'experiment') {
          // Save the current block's trials
          allTrials = allTrials.concat(trials);
          
          window.realBlockIndex++;
          if (realBlockIndex < realExperimentBlocks.length) {
            document.getElementById('experiment').style.display = 'none';
            document.getElementById('message-screen').style.display = 'block';
            
            // Show timer for break between experimental blocks
            let breakTime = 60; // 1 minute
            const t = translations[currentLanguage];

            document.getElementById('message-screen').innerHTML = `
              <p><strong>${t.blockComplete}</strong></p>
              <p>${t.nextBlockStarts}</p>
              <div id="break-timer" class="timer">00:${breakTime < 10 ? '0' + breakTime : breakTime}</div>
              <button id="start-next-real-block">${t.startNextBlock}</button>
            `;
            
            // Start the break timer
            timerInterval = setInterval(() => {
              breakTime--;
              document.getElementById('break-timer').textContent = `00:${breakTime < 10 ? '0' + breakTime : breakTime}`;
              
              if (breakTime <= 0) {
                clearInterval(timerInterval);
                startNextExperimentalBlock();
              }
            }, 1000);
            
            // Add event listener for the skip button
            document.getElementById('start-next-real-block').addEventListener('click', () => {
              clearInterval(timerInterval);
              startNextExperimentalBlock();
            });
            return;
          } else {
            endExperiment();
            return;
          }
        }
      }
      fixationShown = false;
      showFixation();
    }

    function startNextTrialBlock() {
      document.getElementById('message-screen').style.display = 'none';
      document.getElementById('experiment').style.display = 'block';
      trials = initialTrialBlocks[currentBlock];
      totalTrials = trials.length;
      currentTrialIndex = 0;
      updateProgressBar();
      showFixation();
    }

    function startNextExperimentalBlock() {
      document.getElementById('message-screen').style.display = 'none';
      document.getElementById('experiment').style.display = 'block';
      trials = realExperimentBlocks[realBlockIndex].trials;
      totalTrials = trials.length;
      currentTrialIndex = 0;
      updateProgressBar();
      // Update block info display with current language
      document.getElementById('block-info').textContent = realExperimentBlocks[realBlockIndex].name;
      showFixation();
    }

    function startInitialTrialBlock() {
      state = 'initial-trial';
      currentBlock = 0;
      document.getElementById('intro').style.display = 'none';
      document.getElementById('experiment').style.display = 'block';
      initInitialTrials();
      showFixation();
    }

    function startRealExperiment() {
      state = 'experiment';
      document.getElementById('message-screen').style.display = 'none';
      document.getElementById('experiment').style.display = 'block';
      initRealExperimentTrials();
      showFixation();
    }

    function sendDataToLimeSurvey() {
        // Calculate performance metrics
        const responded = allTrials.filter(t => t.responseKey !== null);
        const correct = responded.filter(t => t.correct);
        const accuracy = responded.length > 0 ? (correct.length / responded.length * 100).toFixed(1) : 0;
        const avgRT = correct.length > 0 ? (correct.map(t => t.responseTime).reduce((a, b) => a + b) / correct.length).toFixed(0) : 'N/A';

        // Calculate results by word type
        const emotionalTrials = allTrials.filter(t => t.type === 'emotional');
        const neutralTrials = allTrials.filter(t => t.type === 'neutral');
        
        const emotionalResponded = emotionalTrials.filter(t => t.responseKey !== null);
        const emotionalCorrect = emotionalResponded.filter(t => t.correct);
        const emotionalAccuracy = emotionalResponded.length > 0 ? (emotionalCorrect.length / emotionalResponded.length * 100).toFixed(1) : 0;
        const emotionalAvgRT = emotionalCorrect.length > 0 ? (emotionalCorrect.map(t => t.responseTime).reduce((a, b) => a + b) / emotionalCorrect.length).toFixed(0) : 'N/A';
        
        const neutralResponded = neutralTrials.filter(t => t.responseKey !== null);
        const neutralCorrect = neutralResponded.filter(t => t.correct);
        const neutralAccuracy = neutralResponded.length > 0 ? (neutralCorrect.length / neutralResponded.length * 100).toFixed(1) : 0;
        const neutralAvgRT = neutralCorrect.length > 0 ? (neutralCorrect.map(t => t.responseTime).reduce((a, b) => a + b) / neutralCorrect.length).toFixed(0) : 'N/A';

        const data = {
            email: window.participantEmail,
            trials: allTrials,
            summary: {
                totalTrials: allTrials.length,
                respondedTrials: responded.length,
                accuracy: accuracy,
                avgRT: avgRT,
                emotionalAccuracy: emotionalAccuracy,
                emotionalAvgRT: emotionalAvgRT,
                neutralAccuracy: neutralAccuracy,
                neutralAvgRT: neutralAvgRT
            },
            timestamp: new Date().toISOString(),
            language: currentLanguage
        };
        
        console.log('Sending data to LimeSurvey:', data);
        
        // Invia i dati al parent (LimeSurvey)
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'STROOP_DATA',
                data: data
            }, '*');
        }
        
        // Alternative method: store in localStorage for LimeSurvey to retrieve
        try {
            localStorage.setItem('stroopExperimentData', JSON.stringify(data));
        } catch (e) {
            console.warn('Could not save to localStorage:', e);
        }
    }

    function endExperiment() {
      state = 'finished';
      document.getElementById('canvas-container').style.display = 'none';
      document.getElementById('progress').style.width = '100%';
      document.getElementById('feedback').textContent = '';
      document.getElementById('block-info').style.display = 'none';

      // Use allTrials which contains all experimental blocks
      const responded = allTrials.filter(t => t.responseKey !== null);
      const correct = responded.filter(t => t.correct);
      const accuracy = responded.length > 0 ? (correct.length / responded.length * 100).toFixed(1) : 0;
      const avgRT = correct.length > 0 ? (correct.map(t => t.responseTime).reduce((a, b) => a + b) / correct.length).toFixed(0) : 'N/A';

      // Calculate results by word type
      const emotionalTrials = allTrials.filter(t => t.type === 'emotional');
      const neutralTrials = allTrials.filter(t => t.type === 'neutral');
      
      const emotionalResponded = emotionalTrials.filter(t => t.responseKey !== null);
      const emotionalCorrect = emotionalResponded.filter(t => t.correct);
      const emotionalAccuracy = emotionalResponded.length > 0 ? (emotionalCorrect.length / emotionalResponded.length * 100).toFixed(1) : 0;
      const emotionalAvgRT = emotionalCorrect.length > 0 ? (emotionalCorrect.map(t => t.responseTime).reduce((a, b) => a + b) / emotionalCorrect.length).toFixed(0) : 'N/A';
      
      const neutralResponded = neutralTrials.filter(t => t.responseKey !== null);
      const neutralCorrect = neutralResponded.filter(t => t.correct);
      const neutralAccuracy = neutralResponded.length > 0 ? (neutralCorrect.length / neutralResponded.length * 100).toFixed(1) : 0;
      const neutralAvgRT = neutralCorrect.length > 0 ? (neutralCorrect.map(t => t.responseTime).reduce((a, b) => a + b) / neutralCorrect.length).toFixed(0) : 'N/A';

      const t = translations[currentLanguage];

      const rows = allTrials.map((trial, i) => {
        const rowClass = trial.type === 'emotional' ? 'word-type-emotional' : 'word-type-neutral';
        return `
          <tr class="${rowClass}">
            <td>${i + 1}</td>
            <td>${trial.word}</td>
            <td>${t[trial.type] || trial.type}</td>
            <td>${trial.lang || '-'}</td>
            <td>${t[trial.color] || trial.color}</td>
            <td>${trial.responseKey || '-'}</td>
            <td>${trial.responseTime !== null ? trial.responseTime + ' ms' : '-'}</td>
            <td>${trial.correct ? t.yes : t.no}</td>
            <td>${trial.block || t.practice}</td>
          </tr>
        `;
      }).join('');

      document.getElementById('results-content').innerHTML = `
        <div class="summary-box">
          <h4>${t.overallPerformance}</h4>
          <p>${t.totalTrials} ${allTrials.length}</p>
          <p>${t.responded} ${responded.length}</p>
          <p>${t.accuracy} ${accuracy}%</p>
          <p>${t.averageRT} ${avgRT} ms</p>
        </div>

        <div class="summary-box">
          <h4>${t.performanceByType}</h4>
          <p><strong>${t.emotionalWords}</strong> ${emotionalResponded.length} ${t.responded.toLowerCase()}, ${emotionalAccuracy}% ${t.accuracy.toLowerCase()}, ${emotionalAvgRT} ms ${t.averageRT.toLowerCase()}</p>
          <p><strong>${t.neutralWords}</strong> ${neutralResponded.length} ${t.responded.toLowerCase()}, ${neutralAccuracy}% ${t.accuracy.toLowerCase()}, ${neutralAvgRT} ms ${t.averageRT.toLowerCase()}</p>
        </div>

        <h4>${t.trialDetails}</h4>
        <table class="results-table">
          <thead>
            <tr>
              <th>${t.trialNumber}</th>
              <th>${t.word}</th>
              <th>${t.type}</th>
              <th>${t.language}</th>
              <th>${t.color}</th>
              <th>${t.response}</th>
              <th>${t.rt}</th>
              <th>${t.correct}</th>
              <th>${t.block}</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
      document.getElementById('results').style.display = 'block';
      
      // Send data to LimeSurvey
      sendDataToLimeSurvey();
    }

    function clearCanvas() { 
      background(255); 
    }
    
    function drawWord(word, color) {
      clearCanvas();
      fill(color);
      textSize(48);
      text(word, width / 2, height / 2);
      redraw();
    }

    // Setup function for p5.js
    function setup() {
      canvas = createCanvas(600, 200);
      canvas.parent('canvas-container');
      textAlign(CENTER, CENTER);
      textSize(48);
      noLoop();
    }

    // Key pressed function for p5.js
    function keyPressed() {
      if ((state === 'initial-trial' || state === 'experiment') && fixationShown) {
        const k = key.toLowerCase();
        if (colorKeysMap.red === k || colorKeysMap.yellow === k || colorKeysMap.blue === k) {
          const rt = millis() - startTime;
          processTrialResult(k, rt);
        }
      }
    }

    // Event listeners for language switching
    document.getElementById('lang-en').addEventListener('click', () => updateLanguage('en'));
    document.getElementById('lang-sv').addEventListener('click', () => updateLanguage('sv'));

    // Event listeners
    document.getElementById('email-submit-btn').addEventListener('click', () => {
      const email = document.getElementById('email-input').value.trim();
      const errorDiv = document.getElementById('email-error');

      const isValidEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

      if (isValidEmail) {
        window.participantEmail = email;
        errorDiv.style.display = 'none';
        document.getElementById('email-section').style.display = 'none';
        document.getElementById('intro').style.display = 'block';
        
        // Start the initial timer
        let initialTime = 120; // 2 minutes
        const timerElement = document.getElementById('initial-timer');
        
        timerInterval = setInterval(() => {
          initialTime--;
          const minutes = Math.floor(initialTime / 60);
          const seconds = initialTime % 60;
          timerElement.textContent = `${minutes < 10 ? '0' + minutes : minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
          
          if (initialTime <= 0) {
            clearInterval(timerInterval);
            startInitialTrialBlock();
          }
        }, 1000);
        
        // Add event listener for the skip button
        document.getElementById('skip-initial-timer').addEventListener('click', () => {
          clearInterval(timerInterval);
          startInitialTrialBlock();
        });
      } else {
        errorDiv.style.display = 'block';
      }
    });

    document.addEventListener('click', function (e) {
      if (e.target && e.target.id === 'download-csv') {
        const t = translations[currentLanguage];
        const header = [t.trialNumber, t.word, t.type, t.language, t.color, t.response, t.rt, t.correct, t.block];
        
        const rows = allTrials.map((trial, i) => [
          i + 1,
          `"${trial.word}"`,
          t[trial.type] || trial.type,
          trial.lang || '',
          t[trial.color] || trial.color,
          trial.responseKey || '',
          trial.responseTime !== null ? trial.responseTime : '',
          trial.correct ? t.yes : t.no,
          trial.block || t.practice
        ]);
        
        const csvContent = [header, ...rows].map(row => row.join(',')).join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = 'stroop_results.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    });
  </script>
</body>
</html>

