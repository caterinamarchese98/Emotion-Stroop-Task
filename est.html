<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Emotional Stroop Task - Two Colors</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #d8f3dc 0%, #2575fc 100%);
      margin: 0; padding: 20px;
      display: flex; justify-content: center; align-items: center; min-height: 100vh;
      color: #333;
    }
    #container {
      background-color: white;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      padding: 30px;
      width: 90%;
      max-width: 800px;
      text-align: center;
    }
    h1 { color: #2c3e50; margin-bottom: 20px; }
    h2 { color: #3498db; margin-top: 25px; }
    p { line-height: 1.6; margin-bottom: 15px; }
    .instructions {
      background-color: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      text-align: left;
    }
    .key-instruction {
      display: inline-block;
      background: #e0e0e0;
      padding: 5px 15px;
      border-radius: 5px;
      margin: 5px;
      font-weight: bold;
    }
    .blue-key { color: #2980b9; }
    .red-key { color: #e74c3c; }
    .yellow-key { color: #f1c40f; }
    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 50px;
      font-size: 18px;
      cursor: pointer;
      margin: 20px 0;
      transition: all 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    button:hover {
      background: #2980b9;
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
    }
    #canvas-container {
      margin: 20px auto;
      width: 100%;
      text-align: center;
    }
    .feedback {
      font-size: 24px;
      font-weight: bold;
      margin: 15px 0;
    }
    .progress-bar {
      height: 10px;
      background: #ecf0f1;
      border-radius: 5px;
      margin: 20px 0;
      overflow: hidden;
    }
    .progress {
      height: 100%;
      background: #3498db;
      width: 0%;
      transition: width 0.3s;
    }
    .results {
      text-align: left;
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
    }
    .error {
      color: #e74c3c;
    }
    #email-section {
      margin-bottom: 30px;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    .results-table th, .results-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    .results-table th {
      background-color: #f2f2f2;
    }
    .word-type-emotional {
      background-color: #ffe6e6;
    }
    .word-type-neutral {
      background-color: #e6f2ff;
    }
    .summary-box {
      background-color: #f8f9fa;
      border-left: 4px solid #3498db;
      padding: 15px;
      margin: 15px 0;
      border-radius: 4px;
    }
    .block-info {
      background-color: #e8f4fc;
      padding: 10px;
      border-radius: 8px;
      margin: 10px 0;
      font-weight: bold;
    }
    .timer {
      font-size: 36px;
      font-weight: bold;
      color: #e74c3c;
      margin: 20px 0;
    }
    .timer-container {
      background-color: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
 <div id="container">
    <h1>Emotional Stroop Task</h1>

    <!-- Email Entry Section -->
    <div id="email-section">
      <p>
        Hi, welcome back for the second part of the experiment.<br>
        In this section, you will be required to perform a Stroop Task.<br>
        Please enter the email address you used in the Multilingualism and Emotional Questionnaire (MEQ):
      </p>
      <input type="email" id="email-input" placeholder="your.email@example.com"
             style="padding: 10px; width: 80%; max-width: 400px; border: 1px solid #ccc; border-radius: 5px; font-size: 16px;" />
      <div id="email-error" style="color: #e74c3c; margin-top: 10px; display: none;">Please enter a valid email address.</div>
      <button id="email-submit-btn">Continue</button>
    </div>

    <!-- Intro -->
    <div id="intro" style="display: none;">
      <div class="instructions">
        <p>This study involves categorizing the ink color of words as quickly and accurately as possible.</p>
        <p><strong>Procedure:</strong> You will see words in different colors. Your task is to indicate the color of the <strong>ink</strong>, not the word itself.</p>
        <p>Press <span class="key-instruction red-key">Z</span> for <span style="color: #e74c3c;">RED</span>,
           <span class="key-instruction yellow-key">V</span> for <span style="color: #f1c40f;">YELLOW</span>, and
           <span class="key-instruction blue-key">M</span> for <span style="color: #2980b9;">BLUE</span>.</p>
        <p><em>First, you'll complete 4 short practice blocks.</em></p>
      </div>
      
      <!-- Timer for initial instructions -->
      <div id="initial-timer-container" class="timer-container">
        <p>Please take a moment to review the instructions and remember the keys.</p>
        <div id="initial-timer" class="timer">01:00</div>
        <p>The experiment will start automatically when the timer reaches zero.</p>
        <button id="skip-initial-timer">Start Now</button>
      </div>
    </div>

    <!-- Message screen -->
    <div id="message-screen" style="display:none;"></div>

    <!-- Experiment -->
    <div id="experiment" style="display: none;">
      <div id="block-info" class="block-info"></div>
      <div class="progress-bar"><div class="progress" id="progress"></div></div>
      <div id="canvas-container"></div>
      <div id="feedback" class="feedback"></div>
      <div id="results" class="results" style="display: none;">
        <h2>Experiment Complete!</h2>
        <p>Thank you for your participation.</p>
        <h3>Summary Results</h3>
        <div id="results-content"></div>
        <button id="download-csv" style="margin-top: 15px;">Download CSV</button>
      </div>
    </div>
  </div>

  <script>
    const emotionWords = {
      sv: ["nervös", "sorg", "upprörd", "girighet", "ångest", "avundsjuka", "ensam", "rädd", "rädsla", "panik", "arg", "äcklad", "deprimerad", "galen", "oroad"],
      en: ["nervous", "grief", "upset", "greed", "anxiety", "jealousy", "lonely", "scared", "afraid", "panic", "angry", "disgusted", "depressed", "mad", "troubled"],
      it: ["nervoso", "dolore", "sconvolto", "avidità", "ansia", "gelosia", "solo", "spaventato", "paura", "panico", "arrabbiato", "disgustato", "depresso", "furioso", "turbato"]
    };
    const neutralWords = {
      sv: ["motor", "bom", "akter", "hytt", "köl", "ratt", "säte", "däck", "förare", "propeller", "golv", "ankare", "paddel", "balk", "babord", "rep"],
      en: ["engine", "boom", "stern", "cabin", "keel", "steering wheel", "seat", "deck", "driver", "propeller", "floor", "anchor", "paddle", "beam", "port", "rope"],
      it: ["motore", "bravvio", "poppa", "cabina", "chiglia", "volante", "sedile", "ponte", "conducente", "elica", "pavimento", "ancora", "pagaia", "trave", "sinistro", "corda"]
    };

    const multilingualTrials = {
      animals: ["hund", "katt", "val", "tiger", "lejon", "groda", "delfin", "panda", "koala", "sengångare", "cane", "gatto", "balena", "tigre", "leone", "rana", "delfino", "panda", "koala", "bradipo", "dog", "cat", "whale", "tiger", "lion", "frog", "dolphin", "panda", "koala", "sloth"],
      plants: ["orkidé", "sekvoja", "ormbunke", "kaktus", "lavendel", "bambu", "solros", "lilja", "mossa", "maskros", "orchidea", "sequoia", "felce", "cactus", "lavanda", "bambù", "girasole", "giglio", "muschio", "dente di leone", "orchid", "sequoia", "fern", "cactus", "lavender", "bamboo", "sunflower", "lily", "moss", "dandelion"],
      food: ["spaghetti", "croissant", "guacamole", "cheesecake", "kebab", "pannkaka", "sushi", "lasagne", "tiramisu", "curry", "pancake", "lasagna"],
      transport: ["helikopter", "ubåt", "skateboard", "bil", "flygplan", "skoter", "kajak", "motorcykel", "taxi", "båt", "elicottero", "sottomarino", "skateboard", "auto", "aereo", "scooter", "kayak", "motocicletta", "taxi", "barca", "helicopter", "submarine", "skateboard", "car", "plane", "scooter", "kayak", "motorcycle", "taxi", "boat"]
    };

    const colors = { red: "#e74c3c", yellow: "#f1c40f", blue: "#2980b9" };
    const colorKeysMap = { red: 'z', yellow: 'v', blue: 'm' };
    const keyColorMap = { 'z': 'red', 'v': 'yellow', 'm': 'blue' };

    let state = 'consent', currentTrialIndex = 0, totalTrials = 0, startTime = 0, trials = [], trialTimeout = null, errorTimeout = null, fixationShown = false;
    let initialTrialBlocks = [], currentBlock = 0;
    let canvas;
    let allTrials = []; // Store all trials for final results
    let timerInterval = null; // For managing the timer intervals

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function createTrials(wordArray) {
      const colorKeys = Object.keys(colors);
      return shuffleArray(wordArray.map(word => {
        const color = colorKeys[Math.floor(Math.random() * colorKeys.length)];
        return {
          word,
          color,
          stimulus: `${word} (${color})`,
          responseKey: null,
          responseTime: null,
          correct: null,
          type: 'practice' // Mark as practice trial
        };
      }));
    }
    
    function randomColor() {
      const colorKeys = Object.keys(colors);
      return colorKeys[Math.floor(Math.random() * colorKeys.length)];
    }

    function initInitialTrials() {
      const selectedWords = [];
      Object.values(multilingualTrials).forEach(category => {
        const unique = Array.from(new Set(category));
        selectedWords.push(shuffleArray(unique).slice(0, 10));
      });
      initialTrialBlocks = selectedWords.map(createTrials);
      trials = initialTrialBlocks[currentBlock];
      totalTrials = trials.length;
      currentTrialIndex = 0;
      updateProgressBar();
    }

    function initRealExperimentTrials() {
      function getRandomWords(wordObj, type) {
        const combined = [];
        const keys = Object.keys(wordObj);
        const perLangCount = Math.floor(15 / keys.length);

        keys.forEach(lang => {
          const words = shuffleArray(wordObj[lang]).slice(0, perLangCount);
          words.forEach(w => combined.push({ word: w, lang, type }));
        });

        return shuffleArray(combined);
      }

      const emotionTrials = getRandomWords(emotionWords, 'emotional').map(item => {
        const color = randomColor();
        return {
          word: item.word,
          lang: item.lang,
          color,
          stimulus: `${item.word} (${color})`,
          responseKey: null,
          responseTime: null,
          correct: null,
          type: item.type, // Mark as emotional word
          block: 'emotional' // Add block identifier
        };
      });

      const neutralTrials = getRandomWords(neutralWords, 'neutral').map(item => {
        const color = randomColor();
        return {
          word: item.word,
          lang: item.lang,
          color,
          stimulus: `${item.word} (${color})`,
          responseKey: null,
          responseTime: null,
          correct: null,
          type: item.type, // Mark as neutral word
          block: 'neutral' // Add block identifier
        };
      });

      // Create separate blocks for emotional and neutral words
      window.realExperimentBlocks = [
        {trials: emotionTrials, type: 'emotional', name: 'Emotional Words Block'},
        {trials: neutralTrials, type: 'neutral', name: 'Neutral Words Block'}
      ];
      
      window.realBlockIndex = 0;

      trials = realExperimentBlocks[realBlockIndex].trials;
      totalTrials = trials.length;
      currentTrialIndex = 0;
      updateProgressBar();
      
      // Update block info display
      document.getElementById('block-info').textContent = realExperimentBlocks[realBlockIndex].name;
    }

    function updateProgressBar() {
      document.getElementById('progress').style.width = `${(currentTrialIndex / totalTrials) * 100}%`;
    }

    function showFixation() {
      clearCanvas();
      textSize(36);
      fill(0);
      text("+ + + + +", width / 2, height / 2);
      fixationShown = false;
      setTimeout(() => {
        fixationShown = true;
        showWord();
      }, 300);
    }
    
    function showWord() {
      const trial = trials[currentTrialIndex];
      drawWord(trial.word, colors[trial.color]);
      startTime = millis();
      trialTimeout = setTimeout(() => processTrialResult(null, null), 2500);
    }

    function processTrialResult(key, rt) {
      if (trialTimeout) clearTimeout(trialTimeout);
      const trial = trials[currentTrialIndex];
      if (key !== null) {
        trial.responseKey = key;
        trial.responseTime = rt;
        trial.correct = (keyColorMap[key] === trial.color);
        if (!trial.correct) {
          document.getElementById('feedback').textContent = 'ERROR';
          document.getElementById('feedback').className = 'feedback error';
          errorTimeout = setTimeout(() => advanceToNextTrial(), 750);
          return;
        }
      } else {
        trial.correct = false;
      }
      advanceToNextTrial();
    }

    function advanceToNextTrial() {
      document.getElementById('feedback').textContent = '';
      currentTrialIndex++;
      updateProgressBar();

      if (currentTrialIndex >= totalTrials) {
        if (state === 'initial-trial') {
          currentBlock++;
          if (currentBlock < initialTrialBlocks.length) {
            document.getElementById('experiment').style.display = 'none';
            document.getElementById('message-screen').style.display = 'block';
            
            // Show timer for break between trial blocks
            let breakTime = 30; // 30 seconds
            document.getElementById('message-screen').innerHTML = `
              <p><strong>Trial Block ${currentBlock} complete.</strong></p>
              <p>Next block will start in:</p>
              <div id="break-timer" class="timer">00:${breakTime < 10 ? '0' + breakTime : breakTime}</div>
              <p>Reminder:</p>
              <p>Press <span class="key-instruction red-key">Z</span> for <span style="color: #e74c3c;">RED</span>,
              <span class="key-instruction yellow-key">V</span> for <span style="color: #f1c40f;">YELLOW</span>, and 
              <span class="key-instruction blue-key">M</span> for <span style="color: #2980b9;">BLUE</span>.</p>
              <button id="next-trial-btn">Start Next Trial Block Now</button>
            `;
            
            // Start the break timer
            timerInterval = setInterval(() => {
              breakTime--;
              document.getElementById('break-timer').textContent = `00:${breakTime < 10 ? '0' + breakTime : breakTime}`;
              
              if (breakTime <= 0) {
                clearInterval(timerInterval);
                startNextTrialBlock();
              }
            }, 1000);
            
            // Add event listener for the skip button
            document.getElementById('next-trial-btn').addEventListener('click', () => {
              clearInterval(timerInterval);
              startNextTrialBlock();
            });
            return;
          } else {
            state = 'message';
            document.getElementById('experiment').style.display = 'none';
            document.getElementById('message-screen').style.display = 'block';
            document.getElementById('message-screen').innerHTML = `
              <p><strong>The initial trial blocks are done.</strong></p>
              <p>The real experiment will start now.</p>
              <button id="start-real-btn">Start Real Experiment</button>
            `;
            document.getElementById('start-real-btn').addEventListener('click', startRealExperiment);
            return;
          }
        } else if (state === 'experiment') {
          // Save the current block's trials
          allTrials = allTrials.concat(trials);
          
          window.realBlockIndex++;
          if (realBlockIndex < realExperimentBlocks.length) {
            document.getElementById('experiment').style.display = 'none';
            document.getElementById('message-screen').style.display = 'block';
            
            // Show timer for break between experimental blocks
            let breakTime = 30; // 30 seconds
            document.getElementById('message-screen').innerHTML = `
              <p><strong>Block ${realBlockIndex} complete.</strong></p>
              <p>Next block will start in:</p>
              <div id="break-timer" class="timer">00:${breakTime < 10 ? '0' + breakTime : breakTime}</div>
              <button id="start-next-real-block">Start Next Block Now</button>
            `;
            
            // Start the break timer
            timerInterval = setInterval(() => {
              breakTime--;
              document.getElementById('break-timer').textContent = `00:${breakTime < 10 ? '0' + breakTime : breakTime}`;
              
              if (breakTime <= 0) {
                clearInterval(timerInterval);
                startNextExperimentalBlock();
              }
            }, 1000);
            
            // Add event listener for the skip button
            document.getElementById('start-next-real-block').addEventListener('click', () => {
              clearInterval(timerInterval);
              startNextExperimentalBlock();
            });
            return;
          } else {
            endExperiment();
            return;
          }
        }
      }
      fixationShown = false;
      showFixation();
    }

    function startNextTrialBlock() {
      document.getElementById('message-screen').style.display = 'none';
      document.getElementById('experiment').style.display = 'block';
      trials = initialTrialBlocks[currentBlock];
      totalTrials = trials.length;
      currentTrialIndex = 0;
      updateProgressBar();
      showFixation();
    }

    function startNextExperimentalBlock() {
      document.getElementById('message-screen').style.display = 'none';
      document.getElementById('experiment').style.display = 'block';
      trials = realExperimentBlocks[realBlockIndex].trials;
      totalTrials = trials.length;
      currentTrialIndex = 0;
      updateProgressBar();
      // Update block info display
      document.getElementById('block-info').textContent = realExperimentBlocks[realBlockIndex].name;
      showFixation();
    }

    function startInitialTrialBlock() {
      state = 'initial-trial';
      currentBlock = 0;
      document.getElementById('intro').style.display = 'none';
      document.getElementById('experiment').style.display = 'block';
      initInitialTrials();
      showFixation();
    }

    function startRealExperiment() {
      state = 'experiment';
      document.getElementById('message-screen').style.display = 'none';
      document.getElementById('experiment').style.display = 'block';
      initRealExperimentTrials();
      showFixation();
    }

    function sendDataToLimeSurvey() {
        // Calculate performance metrics
        const responded = allTrials.filter(t => t.responseKey !== null);
        const correct = responded.filter(t => t.correct);
        const accuracy = responded.length > 0 ? (correct.length / responded.length * 100).toFixed(1) : 0;
        const avgRT = correct.length > 0 ? (correct.map(t => t.responseTime).reduce((a, b) => a + b) / correct.length).toFixed(0) : 'N/A';

        // Calculate results by word type
        const emotionalTrials = allTrials.filter(t => t.type === 'emotional');
        const neutralTrials = allTrials.filter(t => t.type === 'neutral');
        
        const emotionalResponded = emotionalTrials.filter(t => t.responseKey !== null);
        const emotionalCorrect = emotionalResponded.filter(t => t.correct);
        const emotionalAccuracy = emotionalResponded.length > 0 ? (emotionalCorrect.length / emotionalResponded.length * 100).toFixed(1) : 0;
        const emotionalAvgRT = emotionalCorrect.length > 0 ? (emotionalCorrect.map(t => t.responseTime).reduce((a, b) => a + b) / emotionalCorrect.length).toFixed(0) : 'N/A';
        
        const neutralResponded = neutralTrials.filter(t => t.responseKey !== null);
        const neutralCorrect = neutralResponded.filter(t => t.correct);
        const neutralAccuracy = neutralResponded.length > 0 ? (neutralCorrect.length / neutralResponded.length * 100).toFixed(1) : 0;
        const neutralAvgRT = neutralCorrect.length > 0 ? (neutralCorrect.map(t => t.responseTime).reduce((a, b) => a + b) / neutralCorrect.length).toFixed(0) : 'N/A';

        const data = {
            email: window.participantEmail,
            trials: allTrials,
            summary: {
                totalTrials: allTrials.length,
                respondedTrials: responded.length,
                accuracy: accuracy,
                avgRT: avgRT,
                emotionalAccuracy: emotionalAccuracy,
                emotionalAvgRT: emotionalAvgRT,
                neutralAccuracy: neutralAccuracy,
                neutralAvgRT: neutralAvgRT
            },
            timestamp: new Date().toISOString()
        };
        
        console.log('Sending data to LimeSurvey:', data);
        
        // Invia i dati al parent (LimeSurvey)
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'STROOP_DATA',
                data: data
            }, '*');
        }
        
        // Alternative method: store in localStorage for LimeSurvey to retrieve
        try {
            localStorage.setItem('stroopExperimentData', JSON.stringify(data));
        } catch (e) {
            console.warn('Could not save to localStorage:', e);
        }
    }

    function endExperiment() {
      state = 'finished';
      document.getElementById('canvas-container').style.display = 'none';
      document.getElementById('progress').style.width = '100%';
      document.getElementById('feedback').textContent = '';
      document.getElementById('block-info').style.display = 'none';

      // Use allTrials which contains all experimental blocks
      const responded = allTrials.filter(t => t.responseKey !== null);
      const correct = responded.filter(t => t.correct);
      const accuracy = responded.length > 0 ? (correct.length / responded.length * 100).toFixed(1) : 0;
      const avgRT = correct.length > 0 ? (correct.map(t => t.responseTime).reduce((a, b) => a + b) / correct.length).toFixed(0) : 'N/A';

      // Calculate results by word type
      const emotionalTrials = allTrials.filter(t => t.type === 'emotional');
      const neutralTrials = allTrials.filter(t => t.type === 'neutral');
      
      const emotionalResponded = emotionalTrials.filter(t => t.responseKey !== null);
      const emotionalCorrect = emotionalResponded.filter(t => t.correct);
      const emotionalAccuracy = emotionalResponded.length > 0 ? (emotionalCorrect.length / emotionalResponded.length * 100).toFixed(1) : 0;
      const emotionalAvgRT = emotionalCorrect.length > 0 ? (emotionalCorrect.map(t => t.responseTime).reduce((a, b) => a + b) / emotionalCorrect.length).toFixed(0) : 'N/A';
      
      const neutralResponded = neutralTrials.filter(t => t.responseKey !== null);
      const neutralCorrect = neutralResponded.filter(t => t.correct);
      const neutralAccuracy = neutralResponded.length > 0 ? (neutralCorrect.length / neutralResponded.length * 100).toFixed(1) : 0;
      const neutralAvgRT = neutralCorrect.length > 0 ? (neutralCorrect.map(t => t.responseTime).reduce((a, b) => a + b) / neutralCorrect.length).toFixed(0) : 'N/A';

      const rows = allTrials.map((t, i) => {
        const rowClass = t.type === 'emotional' ? 'word-type-emotional' : 'word-type-neutral';
        return `
          <tr class="${rowClass}">
            <td>${i + 1}</td>
            <td>${t.word}</td>
            <td>${t.type}</td>
            <td>${t.lang || '-'}</td>
            <td>${t.color}</td>
            <td>${t.responseKey || '-'}</td>
            <td>${t.responseTime !== null ? t.responseTime + ' ms' : '-'}</td>
            <td>${t.correct ? 'Yes' : 'No'}</td>
            <td>${t.block || 'practice'}</td>
          </tr>
        `;
      }).join('');

      document.getElementById('results-content').innerHTML = `
        <div class="summary-box">
          <h4>Overall Performance:</h4>
          <p>Total trials: ${allTrials.length}</p>
          <p>Responded: ${responded.length}</p>
          <p>Accuracy: ${accuracy}%</p>
          <p>Average RT (correct): ${avgRT} ms</p>
        </div>

        <div class="summary-box">
          <h4>Performance by Word Type:</h4>
          <p><strong>Emotional Words:</strong> ${emotionalResponded.length} responded, ${emotionalAccuracy}% accuracy, ${emotionalAvgRT} ms average RT</p>
          <p><strong>Neutral Words:</strong> ${neutralResponded.length} responded, ${neutralAccuracy}% accuracy, ${neutralAvgRT} ms average RT</p>
        </div>

        <h4>Trial Details:</h4>
        <table class="results-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Word</th>
              <th>Type</th>
              <th>Language</th>
              <th>Color</th>
              <th>Response</th>
              <th>RT</th>
              <th>Correct</th>
              <th>Block</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      `;
      document.getElementById('results').style.display = 'block';
      
      // Send data to LimeSurvey
      sendDataToLimeSurvey();
    }

    function clearCanvas() { 
      background(255); 
    }
    
    function drawWord(word, color) {
      clearCanvas();
      fill(color);
      textSize(48);
      text(word, width / 2, height / 2);
      redraw();
    }

    // Setup function for p5.js
    function setup() {
      canvas = createCanvas(600, 200);
      canvas.parent('canvas-container');
      textAlign(CENTER, CENTER);
      textSize(48);
      noLoop();
    }

    // Key pressed function for p5.js
    function keyPressed() {
      if ((state === 'initial-trial' || state === 'experiment') && fixationShown) {
        const k = key.toLowerCase();
        if (colorKeysMap.red === k || colorKeysMap.yellow === k || colorKeysMap.blue === k) {
          const rt = millis() - startTime;
          processTrialResult(k, rt);
        }
      }
    }

    // Event listeners
    document.getElementById('email-submit-btn').addEventListener('click', () => {
      const email = document.getElementById('email-input').value.trim();
      const errorDiv = document.getElementById('email-error');

      const isValidEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);

      if (isValidEmail) {
        window.participantEmail = email;
        errorDiv.style.display = 'none';
        document.getElementById('email-section').style.display = 'none';
        document.getElementById('intro').style.display = 'block';
        
        // Start the initial timer
        let initialTime = 60; // 1 minute
        const timerElement = document.getElementById('initial-timer');
        
        timerInterval = setInterval(() => {
          initialTime--;
          const minutes = Math.floor(initialTime / 60);
          const seconds = initialTime % 60;
          timerElement.textContent = `${minutes < 10 ? '0' + minutes : minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
          
          if (initialTime <= 0) {
            clearInterval(timerInterval);
            startInitialTrialBlock();
          }
        }, 1000);
        
        // Add event listener for the skip button
        document.getElementById('skip-initial-timer').addEventListener('click', () => {
          clearInterval(timerInterval);
          startInitialTrialBlock();
        });
      } else {
        errorDiv.style.display = 'block';
      }
    });

    document.addEventListener('click', function (e) {
      if (e.target && e.target.id === 'download-csv') {
        const header = ['Trial', 'Word', 'Type', 'Language', 'Color', 'Response', 'RT (ms)', 'Correct', 'Block'];
        
        const rows = allTrials.map((t, i) => [
          i + 1,
          `"${t.word}"`,
          t.type,
          t.lang || '',
          t.color,
          t.responseKey || '',
          t.responseTime !== null ? t.responseTime : '',
          t.correct ? 'Yes' : 'No',
          t.block || 'practice'
        ]);
        
        const csvContent = [header, ...rows].map(row => row.join(',')).join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = 'stroop_results.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    });
  </script>
</body>
</html>